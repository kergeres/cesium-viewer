define(["./defaultValue-f6d5e6da","./Matrix3-b2351961","./ArcType-26a3f38d","./arrayRemoveDuplicates-0d8dde26","./Transforms-f17097e5","./Color-47068a02","./ComponentDatatype-ab629b88","./GeometryAttribute-9c1a6bab","./GeometryAttributes-1e4ddcd2","./IndexDatatype-a9b1bc18","./Math-355606c6","./PolylinePipeline-8df321dd","./VertexFormat-fbdec922","./Matrix2-7a8e9daf","./RuntimeError-9b4ce3fb","./combine-0c102d93","./WebGLConstants-7f557f93","./EllipsoidGeodesic-20aaff03","./EllipsoidRhumbLine-1289f7e8","./IntersectionTests-f1b36d69","./Plane-5931b53e"],function(e,t,r,o,a,n,i,l,s,p,d,c,u,y,m,f,h,C,g,_,b){"use strict";let A=[];function E(o){let a=(o=e.defaultValue(o,e.defaultValue.EMPTY_OBJECT)).positions,i=o.colors,l=e.defaultValue(o.width,1),s=e.defaultValue(o.colorsPerVertex,!1);this._positions=a,this._colors=i,this._width=l,this._colorsPerVertex=s,this._vertexFormat=u.VertexFormat.clone(e.defaultValue(o.vertexFormat,u.VertexFormat.DEFAULT)),this._arcType=e.defaultValue(o.arcType,r.ArcType.GEODESIC),this._granularity=e.defaultValue(o.granularity,d.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=t.Ellipsoid.clone(e.defaultValue(o.ellipsoid,t.Ellipsoid.WGS84)),this._workerName="createPolylineGeometry";let p=1+a.length*t.Cartesian3.packedLength;p+=e.defined(i)?1+i.length*n.Color.packedLength:1,this.packedLength=p+t.Ellipsoid.packedLength+u.VertexFormat.packedLength+4}E.pack=function(r,o,a){let i;a=e.defaultValue(a,0);let l=r._positions,s=l.length;for(o[a++]=s,i=0;i<s;++i,a+=t.Cartesian3.packedLength)t.Cartesian3.pack(l[i],o,a);let p=r._colors;for(s=e.defined(p)?p.length:0,o[a++]=s,i=0;i<s;++i,a+=n.Color.packedLength)n.Color.pack(p[i],o,a);return t.Ellipsoid.pack(r._ellipsoid,o,a),a+=t.Ellipsoid.packedLength,u.VertexFormat.pack(r._vertexFormat,o,a),a+=u.VertexFormat.packedLength,o[a++]=r._width,o[a++]=r._colorsPerVertex?1:0,o[a++]=r._arcType,o[a]=r._granularity,o};let P=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),x=new u.VertexFormat,T={positions:void 0,colors:void 0,ellipsoid:P,vertexFormat:x,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};E.unpack=function(r,o,a){let i;o=e.defaultValue(o,0);let l=r[o++],s=Array(l);for(i=0;i<l;++i,o+=t.Cartesian3.packedLength)s[i]=t.Cartesian3.unpack(r,o);l=r[o++];let p=l>0?Array(l):void 0;for(i=0;i<l;++i,o+=n.Color.packedLength)p[i]=n.Color.unpack(r,o);let d=t.Ellipsoid.unpack(r,o,P);o+=t.Ellipsoid.packedLength;let c=u.VertexFormat.unpack(r,o,x);o+=u.VertexFormat.packedLength;let y=r[o++],m=1===r[o++],f=r[o++],h=r[o];return e.defined(a)?(a._positions=s,a._colors=p,a._ellipsoid=t.Ellipsoid.clone(d,a._ellipsoid),a._vertexFormat=u.VertexFormat.clone(c,a._vertexFormat),a._width=y,a._colorsPerVertex=m,a._arcType=f,a._granularity=h,a):(T.positions=s,T.colors=p,T.width=y,T.colorsPerVertex=m,T.arcType=f,T.granularity=h,new E(T))};let w=new t.Cartesian3,D=new t.Cartesian3,k=new t.Cartesian3,V=new t.Cartesian3;return E.createGeometry=function(u){let y,m,f;let h=u._width,C=u._vertexFormat,g=u._colors,_=u._colorsPerVertex,b=u._arcType,E=u._granularity,P=u._ellipsoid,x=[],T=o.arrayRemoveDuplicates(u._positions,t.Cartesian3.equalsEpsilon,!1,x);if(e.defined(g)&&x.length>0){let e=0,t=x[0];g=g.filter(function(r,o){return!(_?o===t||0===o&&1===t:o+1===t)||(t=x[++e],!1)})}let v=T.length;if(v<2||h<=0)return;if(b===r.ArcType.GEODESIC||b===r.ArcType.RHUMB){let t,o;b===r.ArcType.GEODESIC?(t=d.CesiumMath.chordLength(E,P.maximumRadius),o=c.PolylinePipeline.numberOfPoints):(t=E,o=c.PolylinePipeline.numberOfPointsRhumbLine);let a=c.PolylinePipeline.extractHeights(T,P);if(e.defined(g)){let e=1;for(y=0;y<v-1;++y)e+=o(T[y],T[y+1],t);let r=Array(e),a=0;for(y=0;y<v-1;++y){let i=T[y],l=T[y+1],s=g[y],p=o(i,l,t);if(_&&y<e){let e=function(e,t,r,o,a){let i;A.length=a;let l=r.red,s=r.green,p=r.blue,d=r.alpha,c=o.red,u=o.green,y=o.blue,m=o.alpha;if(n.Color.equals(r,o)){for(i=0;i<a;i++)A[i]=n.Color.clone(r);return A}let f=(c-l)/a,h=(u-s)/a,C=(y-p)/a,g=(m-d)/a;for(i=0;i<a;i++)A[i]=new n.Color(l+i*f,s+i*h,p+i*C,d+i*g);return A}(0,0,s,g[y+1],p),t=e.length;for(m=0;m<t;++m)r[a++]=e[m]}else for(m=0;m<p;++m)r[a++]=n.Color.clone(s)}r[a]=n.Color.clone(g[g.length-1]),g=r,A.length=0}T=b===r.ArcType.GEODESIC?c.PolylinePipeline.generateCartesianArc({positions:T,minDistance:t,ellipsoid:P,height:a}):c.PolylinePipeline.generateCartesianRhumbArc({positions:T,granularity:t,ellipsoid:P,height:a})}v=T.length;let L=4*v-4,F=new Float64Array(3*L),G=new Float64Array(3*L),O=new Float64Array(3*L),R=new Float32Array(2*L),I=C.st?new Float32Array(2*L):void 0,S=e.defined(g)?new Uint8Array(4*L):void 0,B,M=0,U=0,N=0,H=0;for(m=0;m<v;++m){let r,o;0===m?(B=w,t.Cartesian3.subtract(T[0],T[1],B),t.Cartesian3.add(T[0],B,B)):B=T[m-1],t.Cartesian3.clone(B,k),t.Cartesian3.clone(T[m],D),m===v-1?(B=w,t.Cartesian3.subtract(T[v-1],T[v-2],B),t.Cartesian3.add(T[v-1],B,B)):B=T[m+1],t.Cartesian3.clone(B,V),e.defined(S)&&(r=0===m||_?g[m]:g[m-1],m!==v-1&&(o=g[m]));let a=m===v-1?2:4;for(f=0===m?2:0;f<a;++f){t.Cartesian3.pack(D,F,M),t.Cartesian3.pack(k,G,M),t.Cartesian3.pack(V,O,M),M+=3;let a=f-2<0?-1:1;if(R[U++]=f%2*2-1,R[U++]=a*h,C.st&&(I[N++]=m/(v-1),I[N++]=Math.max(R[U-2],0)),e.defined(S)){let e=f<2?r:o;S[H++]=n.Color.floatToByte(e.red),S[H++]=n.Color.floatToByte(e.green),S[H++]=n.Color.floatToByte(e.blue),S[H++]=n.Color.floatToByte(e.alpha)}}}let W=new s.GeometryAttributes;W.position=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:F}),W.prevPosition=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:G}),W.nextPosition=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:O}),W.expandAndWidth=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:R}),C.st&&(W.st=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:I})),e.defined(S)&&(W.color=new l.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:S,normalize:!0}));let Y=p.IndexDatatype.createTypedArray(L,6*v-6),q=0,z=0,J=v-1;for(m=0;m<J;++m)Y[z++]=q,Y[z++]=q+2,Y[z++]=q+1,Y[z++]=q+1,Y[z++]=q+2,Y[z++]=q+3,q+=4;return new l.Geometry({attributes:W,indices:Y,primitiveType:l.PrimitiveType.TRIANGLES,boundingSphere:a.BoundingSphere.fromPoints(T),geometryType:l.GeometryType.POLYLINES})},function(r,o){return e.defined(o)&&(r=E.unpack(r,o)),r._ellipsoid=t.Ellipsoid.clone(r._ellipsoid),E.createGeometry(r)}});