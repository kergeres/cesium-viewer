define(["exports","./Matrix2-7a8e9daf","./Matrix3-b2351961","./defaultValue-f6d5e6da","./WebGLConstants-7f557f93","./Transforms-f17097e5"],function(t,e,a,n,r,i){"use strict";var o=Object.freeze({NONE:0,TRIANGLES:1,LINES:2,POLYLINES:3});let s={POINTS:r.WebGLConstants.POINTS,LINES:r.WebGLConstants.LINES,LINE_LOOP:r.WebGLConstants.LINE_LOOP,LINE_STRIP:r.WebGLConstants.LINE_STRIP,TRIANGLES:r.WebGLConstants.TRIANGLES,TRIANGLE_STRIP:r.WebGLConstants.TRIANGLE_STRIP,TRIANGLE_FAN:r.WebGLConstants.TRIANGLE_FAN,isLines:function(t){return t===s.LINES||t===s.LINE_LOOP||t===s.LINE_STRIP},isTriangles:function(t){return t===s.TRIANGLES||t===s.TRIANGLE_STRIP||t===s.TRIANGLE_FAN},validate:function(t){return t===s.POINTS||t===s.LINES||t===s.LINE_LOOP||t===s.LINE_STRIP||t===s.TRIANGLES||t===s.TRIANGLE_STRIP||t===s.TRIANGLE_FAN}};var u=Object.freeze(s);function I(t){t=n.defaultValue(t,n.defaultValue.EMPTY_OBJECT),this.attributes=t.attributes,this.indices=t.indices,this.primitiveType=n.defaultValue(t.primitiveType,u.TRIANGLES),this.boundingSphere=t.boundingSphere,this.geometryType=n.defaultValue(t.geometryType,o.NONE),this.boundingSphereCV=t.boundingSphereCV,this.offsetAttribute=t.offsetAttribute}I.computeNumberOfVertices=function(t){let e=-1;for(let a in t.attributes)if(t.attributes.hasOwnProperty(a)&&n.defined(t.attributes[a])&&n.defined(t.attributes[a].values)){let n=t.attributes[a];e=n.values.length/n.componentsPerAttribute}return e};let N=new a.Cartographic,l=new a.Cartesian3,T=new e.Matrix4,L=[new a.Cartographic,new a.Cartographic,new a.Cartographic],f=[new e.Cartesian2,new e.Cartesian2,new e.Cartesian2],E=[new e.Cartesian2,new e.Cartesian2,new e.Cartesian2],p=new a.Cartesian3,c=new i.Quaternion,m=new e.Matrix4,y=new e.Matrix2;I._textureCoordinateRotationPoints=function(t,n,r,o){let s;let u=e.Rectangle.center(o,N),I=a.Cartographic.toCartesian(u,r,l),b=i.Transforms.eastNorthUpToFixedFrame(I,r,T),C=e.Matrix4.inverse(b,T);L[0].longitude=o.west,L[0].latitude=o.south,L[1].longitude=o.west,L[1].latitude=o.north,L[2].longitude=o.east,L[2].latitude=o.south;let h=p;for(s=0;s<3;s++)a.Cartographic.toCartesian(L[s],r,h),h=e.Matrix4.multiplyByPointAsVector(C,h,h),f[s].x=h.x,f[s].y=h.y;let d=i.Quaternion.fromAxisAngle(a.Cartesian3.UNIT_Z,-n,c),A=a.Matrix3.fromQuaternion(d,m),x=t.length,S=Number.POSITIVE_INFINITY,P=Number.POSITIVE_INFINITY,G=Number.NEGATIVE_INFINITY,R=Number.NEGATIVE_INFINITY;for(s=0;s<x;s++)h=e.Matrix4.multiplyByPointAsVector(C,t[s],h),S=Math.min(S,(h=a.Matrix3.multiplyByVector(A,h,h)).x),P=Math.min(P,h.y),G=Math.max(G,h.x),R=Math.max(R,h.y);let _=e.Matrix2.fromRotation(n,y);E[0].x=S,E[0].y=P,E[1].x=S,E[1].y=R,E[2].x=G,E[2].y=P;let O=f[0],g=f[2].x-O.x,w=f[1].y-O.y;for(s=0;s<3;s++){let t=E[s];e.Matrix2.multiplyByVector(_,t,t),t.x=(t.x-O.x)/g,t.y=(t.y-O.y)/w}let V=E[0],M=E[1],v=E[2],F=Array(6);return e.Cartesian2.pack(V,F),e.Cartesian2.pack(M,F,2),e.Cartesian2.pack(v,F,4),F},t.Geometry=I,t.GeometryAttribute=function(t){t=n.defaultValue(t,n.defaultValue.EMPTY_OBJECT),this.componentDatatype=t.componentDatatype,this.componentsPerAttribute=t.componentsPerAttribute,this.normalize=n.defaultValue(t.normalize,!1),this.values=t.values},t.GeometryType=o,t.PrimitiveType=u});